use crate::{Square, Piece, CastlingSide, Color};


include!(concat!(env!("OUT_DIR"), "/zobrist.rs")); // generated by build.rs

#[inline(always)]
pub fn square(sq: Square, piece: Piece) -> u64 {
    PIECE_SQUARE[sq as usize][<Piece as Into<usize>>::into(piece)]
}

#[inline(always)]
pub fn enpassant(sq: Square) -> u64 {
    ENPASSANT[sq.file() as usize]
}

#[inline(always)]
pub fn castle(castle: CastlingSide, color :Color) -> u64 {
    CASTLE[castle.to_usize(color)]
}

#[inline(always)]
pub fn side() -> u64 {
    SIDE
}

#[inline(always)]
pub fn z_no_pawns() -> u64 {
    NO_PAWNS
}

#[cfg(test)]
mod zobrist_tests {
    use crate::{Square, Piece, Chess, Position};
    use crate::fen::epd;
    use crate::zobrist::square;
    use std::collections::{HashSet, HashMap};
    use rand::Rng;

    #[test]
    fn square_test() {
        let mut hashes = HashSet::new();

        // go through each square and piece combo and make sure they're unique
        for sq in (0..64).into_iter().map(|i| Square::new(i)) {
            for piece in ['p','n','b','r','q','k','P','N','B','R','Q','K'].iter().map(|c| Piece::from_char(*c).unwrap()) {
                let h = square(sq, piece);

                if hashes.contains(&h) {
                    panic!("Zobrist square({}, {:?}) = {} already exists!!!", sq, piece, h);
                } else {
                    hashes.insert(h);
                }
            }
        }

        println!("LEN: {}", hashes.len());
    }

    #[test]
    fn moves_test() {
        // randomly move through a bunch of moves, ensuring we get different zobrist hashes
        const MAX_MOVES :usize = 10_000;
        let mut hash_fen :HashMap<u64, String> = HashMap::new();
        let mut chess = Chess::default();
        let mut rnd = rand::thread_rng();

        while hash_fen.len() < MAX_MOVES {
            // generate and collect all the moves
            let moves = chess.legal_moves();
            let mv_i = rnd.gen_range(0..moves.len());

            // play a random move
            chess.play_unchecked(&moves[mv_i]);

            // get the zobrist hash value
            let z = chess.zobrist();
            let fen = epd(&chess);

            if let Some(existing_fen) = hash_fen.get(&z) {
                // found a collision!!!
                if fen != *existing_fen {
                    panic!("ZOBRIST COLLISION AFTER {}: 0x{:016x}: {} != {}", hash_fen.len(), z, fen, existing_fen);
                }
            } else {
                hash_fen.insert(z, fen);
            }

            // check to see if the game is over, and if so restart it
            if chess.is_game_over() {
                chess = Chess::default();
            }
        }
    }

}